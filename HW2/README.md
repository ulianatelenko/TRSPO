# Monte Carlo Pi 

## Опис проєкту
Цей проєкт реалізує обчислення числа π методом Монте-Карло у **одному потоці** та у **кількох потоках** (2, 4, 8, 16, 32, 64) з вимірюванням часу виконання й розрахунком **speedup**.  
Мета — дослідити, як час обчислення залежить від кількості потоків і де проходить межа ефективного масштабування.

### Ідея методу
У квадраті \[-1, 1] × \[-1, 1] випадково генеруємо точки \((x, y)\). Частка точок, що потрапили в коло радіуса 1, дає оцінку π:  
π ≈ 4 × (hits / samples), де x² + y² ≤ 1


### Обмеження задачі
- **Синхронізація:** дозволено **тільки `Thread.join()`**.  
  Не використовуються `synchronized`, `volatile`, `Atomic*`, `ExecutorService`, бар’єри тощо.
- Кожен потік має **власний лічильник попадань** і **власний генератор випадкових чисел**; агрегація результатів відбувається в головному потоці **після** `join()`.

---

## Аналіз графіка

Графік демонструє класичну поведінку багатопоточної програми:

### 1. Висхідна ділянка (1-4 потоки)
- Час виконання зменшується практично лінійно.  
- Speedup зростає до ~2–2.5×.  
- Кількість потоків відповідає кількості фізичних ядер CPU.

### 2. Плато (8 потоків)
- Прискорення перестає рости.  
- CPU вже повністю завантажений і додавання нових потоків не дає додаткової продуктивності.

### 3. Спад (16–64 потоки)
- Крива йде вниз, час зростає, а speedup падає нижче 1.  
- Причинами можуть бути:  
  - накладні витрати на створення й управління потоками,  
  - часті перемикання контексту між ними.  
- У результаті багатопотокова версія стає навіть повільнішою за однопоточну.

### Загальний висновок
- Оптимальна кількість потоків = кількість фізичних ядер.  
- Подальше збільшення потоків знижує ефективність.  
- Графік підтверджує закон Амдала: максимальне прискорення завжди обмежене послідовною частиною програми та overhead багатопоточності.
